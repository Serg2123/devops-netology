#devops-netology
1. chdir (в самом конце лога strace)
    fork - создание нового дочернего процесса;
    read - попытка читать из файлового дескриптора;
    write - попытка записи в файловый дескриптор;
    open - открыть файл для чтения или записи;
    close - закрыть файл после чтения или записи;
    chdir - изменить текущую директорию;
    execve - выполнить исполняемый файл;
    stat - получить информацию о файле;
    mknod - создать специальный файл, например, файл устройства или сокет.

2. можно сначала так найти возможные file
   find / -name "file" | grep file
   потом вызвав 
    strace file -h 2> out2.txt
   убедиться (в самой первой строчке out2.txt), что file вызывается по пути /usr/bin/file

3. Сначала глазами найдем предполагаемый удаленный файл, который ест место
    sudo lsof | grep deleted
   далее найдем (отфильтровав по искомому файлу) pid процесса, дескриптор и полный путь файла 
    sudo lsof | grep deleted | grep искомый_файл   
   далее убьем процесс по его пиду и файл должен сам "освободиться" и место высвободить.
   Если вдруг место не высвободилось или процесс нельзя убивать, то тогда удаленный файл можно усеч до 0.
   Полный путь к дескриптору можно либо составить самому (/proc/<pid>/fd/указатель_из_lsoft), либо еще раз его найти через найденый pid:
    sudo ls -l /proc/<pid>/fd  /# ищем строку с (deleted), нужный указатель на файл после fd
   далее усекаем файл по полному пути файла указателя 
    cat /dev/null > /proc/<pid>/fd/указатель_на_файл
4. сами зомби процессы ресурсы уже не потребляют, они их уже высвободили т.к. процесс завершился, а его родитель нет или потерялся. Не большое кол-во зомби не так страшно, большое кол-во зомби начинает поедать записи в таблице процессов 
5. opensnoop показывает какие процессы какие файлы открывают, сначала показываютя файлы процесса vminfo, потом dbus-daemon (шина DBus). Знакомая утилита, мы так работу DBus трейсили что бы через DBus повесить доп.обработчик на событие вставки смарт-карты в карт-ридер, что бы в дальнейшем пользователь вводил только пароль (как в Windows), а не логин + пароль как по умолчанию подразумевается в Linux 
6. скорее всего вычитывание информации о процессоре осуществляется системным вызовом mmap, который отображает/вычитывает файл или устройство в память.
    cat /proc/cpuinfo
строка 1634 man proc
       /proc/cpuinfo
              This is a collection of CPU and system architecture dependent items, for each supported architecture  a
              different  list.   Two  common entries are processor which gives CPU number and bogomips; a system con‐
              stant that is calculated during kernel initialization.  SMP machines have  information  for  each  CPU.
              The lscpu(1) command gathers its information from this file.
7. ; - это разделитель последовательного выполнения команд, && - логическое И, т.е. вторая команда выполнится только при успешном выполнении первой.
   Использование "set -e" все же ориентировано скорее на использование внутри скрипта, а не в составе выражения в одной строке, и при "set -e" происходит полная принудительная остановка сценария c любым кодом выхода не равным 0.
   В одной строке && и "set -e" скорее всего нет смысла использовать.

8. set -euxo pipifail
    -e  Exit immediately if a command exits with a non-zero status.
    -u  Treat unset variables as an error when substituting.
    -x  Print commands and their arguments as they are executed.
    -o option-name
    	pipefail     the return value of a pipeline is the status of
                     the last command to exit with a non-zero status,
                     or zero if no command exited with a non-zero status
Дает расширенную построчную отладочную информацию о работе скрипта.
9. Наиболее частые процессы Ss и R+, основные значения S (прерывистый сон,ожидание завершения события) и R (работает или запускается). 
   + и s это расширяющие допзначения: + (находится в группе процессов переднего плана), s (является лидером сеанса).
    







